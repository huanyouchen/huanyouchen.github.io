<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="python，Java，hacker"><title>牛客网上sql专项练习记录 | 幻悠尘的小窝</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-118684665-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6630ddc4c60afb15b88971c6ab1d81a8';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">牛客网上sql专项练习记录</h1><a id="logo" href="/.">幻悠尘的小窝</a><p class="description">The quieter you become,the more you are able to hear.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/projects/"><i class="fa fa-github"> 作品</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/message-board/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">牛客网上sql专项练习记录</h1><div class="post-content"><p>本文内容来自牛客网上数据库SQL实战，题目描述地址： <a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">https://www.nowcoder.com/ta/sql</a></p>
<p>题目顺序按照热度指数排序的，部分题目的思路来自该题目下热门讨论内容。</p>
<a id="more"></a>
<hr>
<p><strong>1.查找最晚入职员工的所有信息</strong></p>
<p>思路：找出最晚入职的员工，即入职的时间是最大的，使用子查询将该条件作为过滤条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> hire_date = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(hire_date) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>
<p>其他思路：把入职时间降序排序，那么排在最前面的就是入职时间最大的，也是最晚入职的员工,然后取该排序序列的第一个。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>但是这个思路不太严谨，摘自该题目后fsy351的解释：最晚入职的当天未必就一个人，也许有多人，使用排序并限制得只能取得指定数量的结果</p>
<p><strong>2.查找入职员工时间排名倒数第三的员工所有信息</strong></p>
<p>思路：把入职时间倒序排序，然后使用LIMIT关键字。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>LIMIT m,n : 表示从第m+1条开始，取n条数据；<br>LIMIT n ： 表示从第0条开始，取n条数据，是limit(0,n)的缩写。</p>
<p>但是这样写不太严谨，比如有多个员工在同一天入职，那么应该按入职日期进行分组，将多个入职日期相同的分为一组，再排序，这样入职时间倒数第三的员工就都可以查出来了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> hire_date = (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> hire_date <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">2</span>,<span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>3.查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_no</strong></p>
<p>思路：把两张表关联起来，设定条件为to_date=9999-01-01  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sa.*,dm.dept_no</span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_manager <span class="keyword">AS</span> dm <span class="keyword">ON</span> dm.emp_no = sa.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> sa.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> dm.to_date=<span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4.查找所有已经分配部门的员工的last_name和first_name</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> em.last_name, em.first_name, de.dept_no</span><br><span class="line"><span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employees <span class="keyword">AS</span> em <span class="keyword">ON</span> de.emp_no = em.emp_no;</span><br></pre></td></tr></table></figure>

<p><strong>5.查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工</strong></p>
<p>思路：以员工为主表，这样即使没有分配部门的员工也可展示出来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> em.last_name, em.first_name, de.dept_no</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> em <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">ON</span> de.emp_no = em.emp_no;</span><br></pre></td></tr></table></figure>

<p><strong>6.查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序</strong></p>
<p>第一次我的错误的写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ep.emp_no, sa.salary</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> ep <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa <span class="keyword">ON</span> ep.emp_no = sa.emp_no</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ep.emp_no <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>刚开始没有明白错在哪里，看讨论区后才知道读题不认真，要求的是查入职时候的薪水，而在salaries表中，每个号码为emp_no的员工会在不同时间段涨薪，这样一个emp_no就对应了多个salary。</p>
<p>因此按照题目要求的查入职时候的薪水，添加条件sa.from_date = ep.hire_date，正确写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ep.emp_no, sa.salary</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> ep <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa <span class="keyword">ON</span> ep.emp_no = sa.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> sa.from_date = ep.hire_date</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ep.emp_no <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><strong>7.查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</strong></p>
<p>思路：把员工分组，使用COUNT()函数计算涨幅次数，使用HAVING条件过滤涨幅次数大于15的，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no, <span class="keyword">COUNT</span>(salary) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no</span><br><span class="line"><span class="keyword">HAVING</span> t&gt;<span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>这样虽然可以通过，但是并不完全正确。COUNT()只是统计次数，并不能判定“涨薪”。<br>比如emp_no为10002的员工：<br>+——–+——–+————+————+<br>| emp_no | salary | from_date  | to_date    |<br>+——–+——–+————+————+<br>| 10002  |  72527 | 1996-08-03 | 1997-08-03 |<br>|  10002 |  72527 | 1997-08-03 | 1998-08-03 |<br>|  10002 |  72527 | 1998-08-03 | 1999-08-03 |<br>|  10002 |  72527 | 1999-08-03 | 2000-08-02 |<br>|  10002 |  72527 | 2000-08-02 | 2001-08-02 |<br>|  10002 |  72527 | 2001-08-02 | 9999-01-01 |</p>
<p>COUNT()统计次数有6次，但是涨薪次数为0次。<br>因此还应该加入下次的salary比本次的salary高，才统计为一次涨薪</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.emp_no, <span class="keyword">COUNT</span>(s1.emp_no) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.emp_no = s2.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> s1.salary &lt; s2.salary <span class="keyword">AND</span> s1.to_date = s2.from_date</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(s1.emp_no)&gt;<span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>不过这个题目这样解没有给通过</p>
<p><strong>8.找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示</strong></p>
<p>思路：使用DISTINCT去重，DESC逆序排列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>其他思路： 如果是针对大量数据的去重，可以使用GROUP BY解决去重，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> salary</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><strong>9. 获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’</strong></p>
<p>思路：将两表联结，取出题目需要的。注意要求的是当前manager的当前薪水情况，两个当前条件都要满足，这里又错了一遍。。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dm.dept_no, dm.emp_no, sa.salary</span><br><span class="line"><span class="keyword">FROM</span> dept_manager <span class="keyword">AS</span> dm <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa <span class="keyword">ON</span> dm.emp_no = sa.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> dm.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> sa.to_date = <span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>10. 获取所有非manager的员工emp_no</strong></p>
<p>思路：先选出所有manager员工的emp_no，再用NOT IN过滤掉这些emp_no</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> emp_no <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> emp_no</span><br><span class="line">    <span class="keyword">FROM</span> dept_manager</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其他思路：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> em.emp_no</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> em</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> emp_no</span><br><span class="line">    <span class="keyword">FROM</span> dept_manager <span class="keyword">AS</span> dm</span><br><span class="line">    <span class="keyword">WHERE</span> em.emp_no = dm.emp_no</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其他思路：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> em.emp_no</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> em <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_manager <span class="keyword">AS</span> dm</span><br><span class="line"><span class="keyword">ON</span> em.emp_no = dm.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> dm.dept_no <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><strong>11.获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。</strong><br>思路：员工的当前管理者：那么员工所在部门<code>dept_no</code>与管理者所在部门<code>dept_no</code>应该是相同的，通过这点将dept_emp表和dept_manager表联结起来，然后判断当前的manager是自己，可以通过员工表中的emp_no和管理者表中emp_no，这两个编号相同即当前的manager是自己，最后设定当前时间。还需要注意员工的manager对应的manager_no在表中是没有的，这个编号就是管理表中的emp_no,把他起个别名manager_no就可以。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> de.emp_no,dm.emp_no <span class="keyword">AS</span> manager_no</span><br><span class="line"><span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_manager <span class="keyword">AS</span> dm <span class="keyword">ON</span> de.dept_no = dm.dept_no</span><br><span class="line"><span class="keyword">WHERE</span> de.to_date=<span class="string">'9999-01-01'</span> <span class="keyword">AND</span> dm.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> de.emp_no != dm.emp_no;</span><br></pre></td></tr></table></figure>

<p><strong>12.获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> de.dept_no,  <span class="keyword">MAX</span>(sa.salary) <span class="keyword">AS</span> salary</span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> de</span><br><span class="line"><span class="keyword">ON</span> sa.emp_no = de.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> de.to_date=<span class="string">'9999-01-01'</span> <span class="keyword">AND</span> sa.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> de.dept_no</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> de.dept_no;</span><br></pre></td></tr></table></figure>


<p><strong>13.从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">COUNT</span>(title) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">FROM</span> titles</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> title</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(title) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>14.从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的title进行忽略。</strong><br>思路： 这个题和13题的区别在于，对重复的title进行去重，比如题目给的数据中，<br>+——–+——————–+————+————+<br>| emp_no | title              | from_date  | to_date    |<br>+——–+——————–+————+————+<br>|  10010 | Engineer           | 1996-11-24 | 9999-01-01 |<br>|  10010 | Engineer           | 1996-11-24 | 9999-01-01 |<br>+——–+——————–+————+————+<br>重复的title指的是emp_no中重复的，因此对emp_no去重</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> emp_no) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">FROM</span> titles</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> title</span><br><span class="line"><span class="keyword">HAVING</span> t &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><strong>15.查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> emp_no % <span class="number">2</span> = <span class="number">1</span> <span class="keyword">AND</span> last_name != <span class="string">'Mary'</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><strong>16. 统计出当前各个title类型对应的员工当前（to_date=’9999-01-01’）薪水对应的平均工资。结果给出title以及平均工资avg。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">AVG</span>(sa.salary) <span class="keyword">AS</span> <span class="keyword">avg</span></span><br><span class="line"><span class="keyword">FROM</span> titles <span class="keyword">AS</span> ti <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa <span class="keyword">ON</span> ti.emp_no = sa.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> sa.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> ti.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ti.title;</span><br></pre></td></tr></table></figure>

<p><strong>17.获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary</strong></p>
<p>我开始是这样写的，也通过了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no,salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>但是看评论时候才发现不严谨，自己想的不够周全，题目要的是薪水第二多的，假如在公司中，当前薪水第一多(设为100万)的有3个人，薪水第二多的有1个人(设为80万)，那么按照上面的排序，结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100万</span><br><span class="line">100万</span><br><span class="line">100万</span><br><span class="line">80万</span><br></pre></td></tr></table></figure>
<p>而<code>LIMIT 1,1</code>选到的是第二个，是100万，但是题目要的是选出80万的，因此，应该对薪水同样多的进行去重，正确的写法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no,salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">WHERE</span> salary = (</span><br><span class="line">    <span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> salary</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>18.查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by</strong></p>
<p>先用MAX()函数选出当前最高者：<code>SELECT MAX(salary) FROM salaries WHERE to_date=&#39;9999-01-01&#39;</code><br>然后在小于最高者的薪水中再选出最高者，即当前排名第二高的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> salaries</span><br><span class="line">    <span class="keyword">WHERE</span> salary &lt; (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span>)</span><br><span class="line">          <span class="keyword">AND</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br></pre></td></tr></table></figure>
<p>最后，联结employees表，选出编号，姓名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.emp_no,sa.salary,emp.last_name,emp.first_name</span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employees <span class="keyword">AS</span> emp </span><br><span class="line"><span class="keyword">ON</span> sa.emp_no = emp.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span> <span class="keyword">AND</span> salary = (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> salaries</span><br><span class="line">    <span class="keyword">WHERE</span> salary &lt; (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span>)</span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>19.查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</strong><br>思路：将三张表联结起来，因为要包括暂时没有分配部门的员工，使用LEFT JOIN</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.last_name, emp.first_name, dpm.dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> emp <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> dep <span class="keyword">ON</span> emp.emp_no = dep.emp_no</span><br><span class="line">                      <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dpm <span class="keyword">ON</span> dep.dept_no = dpm.dept_no;</span><br></pre></td></tr></table></figure>

<p><strong>20.查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth</strong></p>
<p>可以通过但是不严谨的写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">MAX</span>(salary)-<span class="keyword">MIN</span>(salary)) <span class="keyword">AS</span> growth</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">WHERE</span> emp_no = <span class="number">10001</span>;</span><br></pre></td></tr></table></figure>
<p>如果考虑到工资不是一直涨的，比如入职时工资1万，两年后3万，再过半年降成2.5万，现在工资是2.7万，那么入职以来薪水涨幅值是1.7万，而不是3-1=2万<br>因此，应该将最近一次工资减去入职时候第一次的工资，得到的才是涨幅值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (</span><br><span class="line">    (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> emp_no = <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">to_date</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>) -</span><br><span class="line">    (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> emp_no = <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">to_date</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>)</span><br><span class="line">) <span class="keyword">AS</span> growth;</span><br></pre></td></tr></table></figure>
<p><strong>21.查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序</strong><br>思路：本题是求所有员工的，因此可以考虑把薪水salaries表做两份，一份表示当前的，用来得到当前的薪水sa1.salary，另一份是入职时的，用来得到入职时候的薪水sa2.salary。当前这个条件可以设为<code>to_date=&#39;9999-01-01&#39;</code>，入职时候的条件可以设为<code>emp.hire_date = sa2.from_date</code>，那么涨幅情况就可以用当前薪水-入职时的薪水：<code>sa1.salary-sa2.salary</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.emp_no, (sa1.salary-sa2.salary) <span class="keyword">AS</span> growth</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa1 </span><br><span class="line">                            <span class="keyword">ON</span> emp.emp_no = sa1.emp_no <span class="keyword">AND</span> sa1.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line">                      <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa2</span><br><span class="line">                            <span class="keyword">ON</span> emp.emp_no = sa2.emp_no <span class="keyword">AND</span> emp.hire_date = sa2.from_date</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> growth <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<p><strong>22.统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sum</strong></p>
<p>思路：可以通过牛客网提交但是不周全的方案：三表联结，对部分分组，使用COUNT()统计次数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dm.dept_no, dm.dept_name, <span class="keyword">COUNT</span>(salary) <span class="keyword">AS</span> <span class="keyword">sum</span></span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">ON</span> sa.emp_no = de.emp_no</span><br><span class="line">                    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dm <span class="keyword">ON</span> dm.dept_no = de.dept_no</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dm.dept_no, dm.dept_name;</span><br></pre></td></tr></table></figure>
<p>和前面一道涨幅次数超过15次的题目很像，需要判定是涨的记录，而不是不变或降的记录。因此我这样写的，但是没有通过提交。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dm.dept_no, dm.dept_name, <span class="keyword">COUNT</span>(sa1.emp_no) <span class="keyword">AS</span> <span class="keyword">sum</span></span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa2 <span class="keyword">ON</span> sa1.emp_no = sa2.emp_no</span><br><span class="line">                     <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">ON</span> sa1.emp_no = de.emp_no</span><br><span class="line">                     <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dm <span class="keyword">ON</span> dm.dept_no = de.dept_no</span><br><span class="line"><span class="keyword">WHERE</span> sa1.salary&lt;sa2.salary <span class="keyword">AND</span> sa1.to_date = sa2.from_date</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dm.dept_no, dm.dept_name;</span><br></pre></td></tr></table></figure>

<p><strong>23.对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列</strong></p>
<p>思路：如果支持窗口函数，根据相同的salary并列，排名为：1,2,2,3,3,3,4这样的顺序，那么可以使用dense_rank()窗口函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no, salary, <span class="keyword">dense_rank</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">FROM</span> salaries </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>, emp_no <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<p>但是如果不支持窗口函数，要对工资进行1-N的排名，不用窗口函数对单个表显示排名，我一开始没有思路，，后来看了讨论区，理解了热评里的实现过程。把salary表做成两份，进行对比，一份是原表sa1，另一份是排名用的表sa2。如果某工资排名第五，那么就是说有比他工资高(<code>sa1.salary &lt;= sa2.salary</code>)的有4份，如果某工资排名第二，那么就是说有比他工资高有1份，可以使用COUNT()来统计比某份工资高的个数来当做排名。<br>还需要注意去重，比如s1.salary=94409时，有3个s2.salary（分别为94692,94409,94409）大于等于它，但由于94409重复，利用COUNT(DISTINCT s2.salary)去重可得工资为94409的rank等于2<br>最后排名时，工资salary逆序排，最大的为第一名，emp_no升序排列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sa1.emp_no, sa1.salary, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> sa2.salary) <span class="keyword">AS</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa2 <span class="keyword">ON</span> sa2.emp_no = sa2.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> sa1.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> sa2.to_date = <span class="string">'9999-01-01'</span> </span><br><span class="line">      <span class="keyword">AND</span> sa1.salary &lt;= sa2.salary</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sa1.emp_no,sa1.salary</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sa1.salary <span class="keyword">DESC</span>, sa1.emp_no <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p><strong>24.获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date=’9999-01-01’</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> de.dept_no, sa.emp_no, sa.salary</span><br><span class="line"><span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa </span><br><span class="line"><span class="keyword">ON</span> sa.emp_no = de.emp_no <span class="keyword">AND</span> sa.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">WHERE</span> de.emp_no <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_manager <span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>25.获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date=’9999-01-01’,结果第一列给出员工的emp_no，第二列给出其manager的manager_no，第三列给出该员工当前的薪水emp_salary,第四列给该员工对应的manager当前的薪水manager_salary</strong></p>
<p>来自本题热评中wasrehpic的思路：<br>本题主要思想是创建两张表（一张记录当前所有员工的工资，另一张只记录部门经理的工资）进行比较，具体思路如下：<br>1、先用INNER JOIN连接salaries和demp_emp，建立当前所有员工的工资记录sde<br>2、再用INNER JOIN连接salaries和demp_manager，建立当前所有经理的工资记录sdm<br>3、最后用限制条件sem.dept_no = sdm.dept_no AND sem.salary &gt; sdm.salary找出同一部门中工资比经理高的员工，并根据题意依次输出emp_no、manager_no、emp_salary、manager_salary</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sde.emp_no <span class="keyword">AS</span> emp_no, sdm.emp_no <span class="keyword">AS</span> manager_no, sde.salary <span class="keyword">AS</span> emp_salary, sdm.salary <span class="keyword">AS</span> manager_salary</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> sa.salary, sa.emp_no, de.dept_no</span><br><span class="line">    <span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> de</span><br><span class="line">    <span class="keyword">ON</span> sa.emp_no = de.emp_no <span class="keyword">AND</span> sa.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line">    )<span class="keyword">AS</span> sde,</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> sa.salary, sa.emp_no, dm.dept_no</span><br><span class="line">        <span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_manager <span class="keyword">AS</span> dm</span><br><span class="line">        <span class="keyword">ON</span> sa.emp_no = dm.emp_no <span class="keyword">AND</span> sa.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line">    ) <span class="keyword">AS</span> sdm</span><br><span class="line"><span class="keyword">WHERE</span> sde.dept_no = sdm.dept_no <span class="keyword">AND</span> sde.salary &gt; sdm.salary;</span><br></pre></td></tr></table></figure>
<p><strong>26.汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当前员工所有的title以及该类型title对应的数目count</strong><br>思路：首先需要对各个部门进行分组,分组后得到的每组是某个部门的员工。员工可能有多个类型的title，要统计某类型title对应的数目，还需要对title进行分组，这样两次分组后，只有同一部门且同一title的才是一个组。当前员工的当前title，员工和title都需要加to_date的限制。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> de.dept_no, dm.dept_name, t.title, <span class="keyword">COUNT</span>(t.title)</span><br><span class="line"><span class="keyword">FROM</span> departments <span class="keyword">AS</span> dm <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> de </span><br><span class="line">                       <span class="keyword">ON</span> dm.dept_no = de.dept_no <span class="keyword">AND</span> de.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line">                       <span class="keyword">INNER</span> <span class="keyword">JOIN</span> titles <span class="keyword">AS</span> t</span><br><span class="line">                       <span class="keyword">ON</span> de.emp_no = t.emp_no <span class="keyword">AND</span> t.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> de.dept_no, t.title;</span><br></pre></td></tr></table></figure>

<p><strong>27.给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。提示：在sqlite中获取datetime时间对应的年份函数为strftime(‘%Y’, to_date)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sa1.emp_no, sa2.from_date, (sa2.salary - sa1.salary) <span class="keyword">AS</span> salary_growth</span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa2 <span class="keyword">ON</span> sa1.emp_no = sa2.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> sa2.salary-sa1.salary&gt;<span class="number">5000</span> </span><br><span class="line"><span class="keyword">AND</span> (</span><br><span class="line">    strftime(<span class="string">'%Y'</span>, sa2.to_date) - strftime(<span class="string">'%Y'</span>, sa1.to_date) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">OR</span></span><br><span class="line">    strftime(<span class="string">'%Y'</span>, sa2.from_date) - strftime(<span class="string">'%Y'</span>, sa1.from_date) = <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary_growth <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><strong>28.查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量&gt;=5部</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.name,<span class="keyword">COUNT</span>(fc.film_id)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> category_id</span><br><span class="line">        <span class="keyword">FROM</span> film_category</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id</span><br><span class="line">        <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(film_id) &gt;= <span class="number">5</span></span><br><span class="line">    ) <span class="keyword">AS</span> cc,</span><br><span class="line">    film <span class="keyword">AS</span> f,</span><br><span class="line">    <span class="keyword">category</span> <span class="keyword">AS</span> c,</span><br><span class="line">    film_category <span class="keyword">AS</span> fc</span><br><span class="line"><span class="keyword">WHERE</span> f.description <span class="keyword">LIKE</span> <span class="string">'%robot%'</span></span><br><span class="line"><span class="keyword">AND</span> c.category_id = fc.category_id</span><br><span class="line"><span class="keyword">AND</span> c.category_id = cc.category_id</span><br><span class="line"><span class="keyword">AND</span> fc.film_id = f.film_id;</span><br></pre></td></tr></table></figure>

<p><strong>29.使用join查询方式找出没有分类的电影id以及名称</strong><br>方法一</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> f.film_id, f.title</span><br><span class="line"><span class="keyword">FROM</span> film <span class="keyword">AS</span> f <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> film_category <span class="keyword">AS</span> fc</span><br><span class="line"><span class="keyword">ON</span> f.film_id = fc.film_id</span><br><span class="line"><span class="keyword">WHERE</span> fc.category_id <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id, film.title</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> film.film_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id</span><br><span class="line">    <span class="keyword">FROM</span> film_category</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>30.使用子查询的方式找出属于Action分类的所有电影对应的title,description</strong></p>
<p>子查询方法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, description</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id</span><br><span class="line">    <span class="keyword">FROM</span> film_category</span><br><span class="line">    <span class="keyword">WHERE</span> category_id <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> category_id</span><br><span class="line">        <span class="keyword">FROM</span> <span class="keyword">category</span></span><br><span class="line">        <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Action'</span></span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>非子查询方法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> f.title, f.description</span><br><span class="line"><span class="keyword">FROM</span> film <span class="keyword">AS</span> f <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_category <span class="keyword">AS</span> fc <span class="keyword">ON</span> f.film_id =fc.film_id</span><br><span class="line">               <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">category</span> <span class="keyword">AS</span> c <span class="keyword">ON</span> c.category_id = fc.category_id</span><br><span class="line"><span class="keyword">WHERE</span> c.name = <span class="string">'Action'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>31.获取select * from employees对应的执行计划</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p><strong>32.将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// mysql写法</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="keyword">concat</span>(last_name, <span class="string">" "</span>), first_name)</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">//sqlite写法</span><br><span class="line"><span class="keyword">SELECT</span> last_name||<span class="string">" "</span>||first_name <span class="keyword">AS</span> <span class="keyword">Name</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p><strong>33.创建一个actor表，包含如下列信息</strong></p>
<p>列表    类型    是否为NULL    含义<br>actor_id    smallint(5)    not null    主键id<br>first_name    varchar(45)    not null    名字<br>last_name    varchar(45)    not null    姓氏<br>last_update    timestamp    not null    最后更新时间，默认是系统的当前时间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//sqlite写法</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> actor(</span><br><span class="line">    actor_id <span class="built_in">smallint</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_update <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> (datetime(<span class="string">'now'</span>, <span class="string">'localtime'</span>)),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(actor_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//mysql写法</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> actor(</span><br><span class="line">    actor_id <span class="built_in">smallint</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_update <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_timestamp</span> <span class="keyword">COMMENT</span> <span class="string">'最后更新时间，默认是系统的当前时间'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(actor_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>34.对于表actor批量插入如下数据</strong><br>actor_id    first_name    last_name    last_update<br>1    PENELOPE    GUINESS    2006-02-15 12:34:33<br>2    NICK    WAHLBERG    2006-02-15 12:34:33</p>
<p>注意插入字符串时用引号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> actor <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">'PENELOPE'</span>, <span class="string">'GUINESS'</span>, <span class="string">'2006-02-15 12:34:33'</span>),</span><br><span class="line">                        (<span class="number">2</span>, <span class="string">'NICK'</span>, <span class="string">'WAHLBERG'</span>, <span class="string">'2006-02-15 12:34:33'</span>);</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> actor(actor_id, first_name, last_name, last_update) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'PENELOPE'</span>, <span class="string">'GUINESS'</span>, <span class="string">'2006-02-15 12:34:33'</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">'NICK'</span>, <span class="string">'WAHLBERG'</span>, <span class="string">'2006-02-15 12:34:33'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>35. 对于表actor批量插入如下数据,如果数据已经存在，请忽略，不使用replace操作</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//sqlite</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> actor <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">'ED'</span>, <span class="string">'CHASE'</span>, <span class="string">'2006-02-15 12:34:33'</span>);</span><br><span class="line"></span><br><span class="line">//mysql</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> actor <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">'ED'</span>, <span class="string">'CHASE'</span>, <span class="string">'2006-02-15 12:34:33'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>36.对于如下表actor，其对应的数据为:</strong><br>actor_id    first_name    last_name    last_update<br>1    PENELOPE    GUINESS    2006-02-15 12:34:33<br>2    NICK    WAHLBERG    2006-02-15 12:34:33</p>
<p>创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表。 actor_name表结构如下：<br>列表    类型    是否为NULL    含义<br>first_name    varchar(45)    not null    名字<br>last_name    varchar(45)    not null    姓氏</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> actor_name(</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_name  <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> actor_name (first_name, last_name) <span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> actor;</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> actor_name <span class="keyword">as</span> <span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> actor;</span><br></pre></td></tr></table></figure>

<p><strong>37. 对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uniq_idx_firstname <span class="keyword">ON</span> actor(first_name);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_lastname <span class="keyword">ON</span> actor(last_name);</span><br></pre></td></tr></table></figure>

<p><strong>38.针对actor表创建视图actor_name_view，只包含first_name以及last_name两列，并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> actor_name_view (first_name_v, last_name_v) <span class="keyword">AS</span> </span><br><span class="line">    <span class="keyword">SELECT</span> first_name,last_name <span class="keyword">FROM</span> actor</span><br></pre></td></tr></table></figure>

<p><strong>39.针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//SQLite</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> salaries INDEXED <span class="keyword">BY</span> idx_emp_no <span class="keyword">WHERE</span> emp_no = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line">//MySQL</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> salaries <span class="keyword">FORCE</span> <span class="keyword">INDEX</span> idx_emp_no <span class="keyword">WHERE</span> emp_no = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><strong>40. 现在在last_update后面新增加一列名字为create_date, 类型为datetime, NOT NULL，默认值为’0000 00:00:00’</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> actor <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> create_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000-00-00 00:00:00'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>41. 构造一个触发器audit_log，在向employees_test表中插入一条数据的时候，触发插入相关的数据到audit中。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> audit_log <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees_test</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">audit</span> <span class="keyword">VALUES</span> (NEW.ID, NEW.NAME);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p><strong>42. 删除emp_no重复的记录，只保留最小的id对应的记录。</strong><br>思路：先把emp_no分组，在每组中找出最小的id，然后把非最小的都给删掉</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> titles_test <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> titles_test <span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>43. 将所有to_date为9999-01-01的全部更新为NULL,且 from_date更新为2001-01-01。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> titles_test <span class="keyword">SET</span> <span class="keyword">to_date</span> = <span class="literal">NULL</span>, from_date = <span class="string">'2001-01-01'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>44. 将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> titles_test <span class="keyword">VALUES</span>(<span class="string">'5'</span>, <span class="string">'10005'</span>, <span class="string">'Senior Engineer'</span>, <span class="string">'1986-06-26'</span>, <span class="string">'9999-01-01'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>45. 将titles_test表名修改为titles_2017。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> titles_test <span class="keyword">RENAME</span> <span class="keyword">TO</span> titles_2017;</span><br></pre></td></tr></table></figure>

<p><strong>46.在audit表上创建外键约束，其emp_no对应employees_test表的主键id。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//mysql</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">audit</span> <span class="keyword">ADD</span> FROEIGN <span class="keyword">KEY</span> (emp_no) REFERNCES employees_test (<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line">//通过测试</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">audit</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">audit</span>(</span><br><span class="line">    EMP_no <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    create_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(EMP_no) <span class="keyword">REFERENCES</span> employees_test(<span class="keyword">ID</span>));</span><br></pre></td></tr></table></figure>

<p><strong>47.存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005;如何获取emp_v和employees有相同的数据?</strong></p>
<p>INETRSECT和 UNION 指令类似，INTERSECT 也是对两个 SQL 语句所产生的结果做处理的。不同的地方是， UNION 基本上是一个 OR (如果这个值存在于第一句或是第二句，它就会被选出)，而 INTERSECT 则比较像 AND ( 这个值要存在于第一句和第二句才会被选出)。UNION 是联集，而 INTERSECT 是交集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">INTERSECT</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp_v;</span><br></pre></td></tr></table></figure>

<p><strong>48. 将所有获取奖金的员工当前的薪水增加10%。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> salaries <span class="keyword">SET</span> salary = salary * <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span> <span class="keyword">AND</span> emp_no <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> emp_bonus</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>49. 针对库中的所有表生成select count(*)对应的SQL语句</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//sqlite</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">"select count(*) from "</span> || <span class="keyword">name</span> || <span class="string">";"</span> <span class="keyword">AS</span> cnts</span><br><span class="line"><span class="keyword">FROM</span> sqlite_master <span class="keyword">WHERE</span> <span class="keyword">type</span> = <span class="string">'table'</span>;</span><br><span class="line"></span><br><span class="line">//mysql</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="string">'SELECT COUNT(*) FROM '</span>, new.table_name, <span class="string">';'</span>) <span class="keyword">AS</span> cnts</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> table_name</span><br><span class="line">    <span class="keyword">FROM</span> information_schema.tables</span><br><span class="line">    <span class="keyword">WHERE</span> table_schema = <span class="string">'sql_nowcoder'</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<p><strong>50.将employees表中的所有员工的last_name和first_name通过(‘)连接起来。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//sqlite</span><br><span class="line"><span class="keyword">SELECT</span> last_name || <span class="string">"'"</span> || first_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">//mysql</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(last_name, <span class="string">"'"</span>, first_name)</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p><strong>51.查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (</span><br><span class="line">    (<span class="keyword">length</span>(<span class="string">"10,A,B"</span>) - <span class="keyword">length</span>(<span class="keyword">replace</span>(<span class="string">"10,A,B"</span>, <span class="string">","</span>, <span class="string">""</span>))) / <span class="keyword">length</span>(<span class="string">","</span>)</span><br><span class="line">) <span class="keyword">AS</span> cnt;</span><br></pre></td></tr></table></figure>

<p><strong>52.获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列</strong></p>
<p>substr(string,start,length)</p>
<ul>
<li>string 指定的要截取的字符串。</li>
<li>start 必需，规定在字符串的何处开始。正数 - 在字符串的指定位置开始，负数 - 在从字符串结尾的指定位置开始，0 - 在字符串中的第一个字符处开始。</li>
<li>length 可选，指定要截取的字符串长度，缺省时返回字符表达式的值结束前的全部字符。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//sqlite</span><br><span class="line"><span class="keyword">SELECT</span> first_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">substr</span>(first_name, <span class="keyword">length</span>(first_name)<span class="number">-1</span>, <span class="number">2</span>) <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">//mysql</span><br><span class="line"><span class="keyword">SELECT</span> first_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">RIGHT</span>(first_name,<span class="number">2</span>) <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>53.按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees</strong></p>
<p>思路: 聚合函数group_concat(X,Y)，其中X是要连接的字段，Y是连接时用的符号，可省略，默认为逗号。此函数必须与 GROUP BY 配合使用。此题以 dept_no 作为分组，将每个分组中不同的emp_no用逗号连接起来（即可省略Y）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> dept_no, <span class="keyword">group_concat</span>(emp_no) <span class="keyword">AS</span> employees</span><br><span class="line"><span class="keyword">FROM</span> dept_emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_no;</span><br></pre></td></tr></table></figure>

<p><strong>54.查找排除当前最大、最小salary之后的员工的平均工资avg_salary。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> salaries </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span> </span><br><span class="line"><span class="keyword">AND</span> salary <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span> )</span><br><span class="line"><span class="keyword">AND</span> salary <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary) <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span> );</span><br></pre></td></tr></table></figure>

<p><strong>55.分页查询employees表，每5行一页，返回第2页的数据</strong></p>
<p>思路：第2页的行数为第6-10行，可以用LIMIT 5, OFFSET 5</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">LIMIT</span> <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>56.获取所有员工的emp_no、部门编号dept_no以及对应的bonus类型btype和received ，没有分配具体的员工不显示</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> em.emp_no, de.dept_no, eb.btype, eb.recevied</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> em <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> de</span><br><span class="line"><span class="keyword">ON</span> em.emp_no = de.emp_no</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> emp_bonus <span class="keyword">AS</span> eb </span><br><span class="line"><span class="keyword">ON</span> de.emp_no = eb.emp_no;</span><br></pre></td></tr></table></figure>

<p><strong>57.获取employees中的行数据，且这些行也存在于emp_v中。注意不能使用intersect关键字</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp_v;</span><br></pre></td></tr></table></figure>

<p><strong>58.获取有奖金的员工相关信息。给出emp_no、first_name、last_name、奖金类型btype、对应的当前薪水情况salary以及奖金金额bonus。 bonus类型btype为1其奖金为薪水salary的10%，btype为2其奖金为薪水的20%，其他类型均为薪水的30%。 当前薪水表示to_date=’9999-01-01’</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.emp_no, emp.first_name, emp.last_name, eb.btype, sa.salary,</span><br><span class="line">       (<span class="keyword">CASE</span> eb.btype</span><br><span class="line">             <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> sa.salary*<span class="number">0.1</span> </span><br><span class="line">             <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> sa.salary*<span class="number">0.2</span></span><br><span class="line">             <span class="keyword">ELSE</span> sa.salary*<span class="number">0.3</span></span><br><span class="line">        <span class="keyword">END</span>) <span class="keyword">AS</span> bonus</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> emp_bonus <span class="keyword">AS</span> eb <span class="keyword">ON</span> emp.emp_no = eb.emp_no</span><br><span class="line">                      <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa <span class="keyword">ON</span> emp.emp_no = sa.emp_no <span class="keyword">AND</span> sa.to_date=<span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>59. 按照salary的累计和running_total，其中running_total为前两个员工的salary累计和，其他以此类推。 *</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//窗口函数方法</span><br><span class="line"><span class="keyword">SELECT</span> emp_no, salary, </span><br><span class="line">       <span class="keyword">SUM</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">order</span> <span class="keyword">by</span> emp_no) <span class="keyword">AS</span> running_total</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span>;</span><br><span class="line"></span><br><span class="line">//联结表写法</span><br><span class="line"><span class="keyword">SELECT</span> sa2.emp_no, sa2.salary, <span class="keyword">SUM</span>(sa1.salary) <span class="keyword">AS</span> running_total</span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> sa1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> sa2</span><br><span class="line"><span class="keyword">ON</span> sa1.emp_no &lt;= sa2.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> sa1.to_date = <span class="string">"9999-01-01"</span> <span class="keyword">AND</span> sa2.to_date = <span class="string">"9999-01-01"</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sa2.emp_no;</span><br></pre></td></tr></table></figure>

<p><strong>60. 对于employees表中，给出奇数行的first_name</strong></p>
<p>思路：有多少个大于等于e2.first_name的记录的个数就是e2.first_name的行号，比如：</p>
<p>如果 e1.first_name 是第一位，那 e2.first_name 只有1个，就是 e1.first_name 本身，1%2=1；<br>如果 e1.first_name 排在第二位，就有它和比它小的这2个e2.first_name，2%2=0，所以不选，<br>以此类推。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.first_name <span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> employees e2</span><br><span class="line">    <span class="keyword">WHERE</span> e1.first_name &gt;= e2.first_name</span><br><span class="line">) % <span class="number">2</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</div></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://huanyouchen.github.io/2019/09/09/SQL-specific-exercise-records-on-nowcoder/';
    this.page.identifier = '2019/09/09/SQL-specific-exercise-records-on-nowcoder/';
    this.page.title = '牛客网上sql专项练习记录';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//huanyouchen-blog.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//huanyouchen-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://huanyouchen-blog.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">幻悠尘的小窝.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>