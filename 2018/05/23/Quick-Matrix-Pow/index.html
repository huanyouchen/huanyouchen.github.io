<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="python，Java，hacker"><title>矩阵快速幂 | 幻悠尘的小窝</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-118684665-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6630ddc4c60afb15b88971c6ab1d81a8';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">矩阵快速幂</h1><a id="logo" href="/.">幻悠尘的小窝</a><p class="description">The quieter you become,the more you are able to hear.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/projects/"><i class="fa fa-github"> 作品</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/message-board/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">矩阵快速幂</h1><div class="post-content"><p>矩阵的快速幂是用来高效地计算矩阵的高次方的。将朴素的o（n）的时间复杂度，降到log（n）。<br>本文先学习快速幂和矩阵乘法的基础知识，然后将两者结合实现矩阵快速幂方法。然后举一个例子：使用矩阵快速幂求斐波那契数列。</p>
<hr>
<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>一般计算底数x的n次幂$x^n$ 的方法： $x^n = x × x × x … x × x$ ,需要做n次乘法运算，代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powx</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        res = res * x</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(powx(x,n))</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(N), 当n非常大时候运算效率很低。怎么才能提高运算效率来快速计算底数x的n次幂呢？可以通过快速幂方法。</p>
<p>先用一个具体的例子解释其原理：比如，计算x的11次方$x^{11}$，而11可以用二进制表示： $$11 = 1011 = 1 × 2^3 + 0 × 2^2 + 1 × 2^1 + 1 ×2^0$$</p>
<p>那么可以把$x^{11}$转换为：<br>$$x^{11} = x ^ {2^3} × x ^ {2^1} × x^{2^0} = x^8 × x^2 × x^1 $$</p>
<p>原先需要做11次乘法运算，转换后只需要3次乘法运算。</p>
<p>通过上面的具体例子来推导一般情况计算$x^n$ 的方法，先把n转换为2进制，从低位到高位根据二进制中的0或者1来进行乘法运算，比如上面的$x^{11}$例子，从低位到高位的运算过程：</p>
<ul>
<li>11 = 1011</li>
<li>1：res = $x^{2^0}$</li>
<li>1: res = $x^{2^0} × x^{2^1}$</li>
<li>0: 跳过，不运算</li>
<li>1：res = $x^{2^0} × x^{2^1} × x^{2^3}$</li>
</ul>
<p>得到结果res = $x^{1} × x^{2} × x^{8} = x ^ {11}$</p>
<p>判断n的二进制低位是0或者1的方法, 也就是判断n是偶数或者奇数的方法，可以通过位运算<code>and</code>来实现：</p>
<ul>
<li>n and 1 返回1， 则n是奇数，即n的二进制低位是1</li>
<li>n and 1 返回0， 则n是偶数，即n的二进制低位是0</li>
</ul>
<p>从低位到高位的运算过程也可以通过位运算<code>&gt;&gt;</code>实现， n = n &gt;&gt; 1, 把n的二进制位右移过程也就是高位到低位的过程。比如11 = 1011的右移过程:</p>
<ul>
<li>n = n &gt;&gt; 1 = 1011 &gt;&gt; 1 = 101</li>
<li>n = n &gt;&gt; 1 = 101 &gt;&gt; 1 = 10</li>
<li>n = n &gt;&gt; 1 = 10 &gt;&gt; 1 = 1</li>
<li>n = n &gt;&gt; 1 = 1 &gt;&gt; 1 = 0</li>
</ul>
<p>根据上面分析，快速幂的代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powx</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">            res = res * x</span><br><span class="line">        x = x * x</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(powx(x,n))</span><br></pre></td></tr></table></figure>

<p>上面快速幂代码中第5,6行涉及到两步乘法运算，当x很大时，比如$98765432^{11}$, 这样直接乘效率也比较低，可以通过快速乘法进一步优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#快速乘法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fast_multi</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    multi_res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        <span class="keyword">if</span> b&amp;<span class="number">1</span>:</span><br><span class="line">            multi_res = multi_res + a</span><br><span class="line">        a = a+a</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> multi_res</span><br><span class="line"> </span><br><span class="line"><span class="comment">#快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powx</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">            res = fast_multi(res, x)</span><br><span class="line">        x = fast_multi(x, x)</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>矩阵：一个$m×n$的矩阵就是$m×n$个数排成m行n列的一个数阵。</p>
<p>矩阵乘法：设A为$m×p$的矩阵，B为$p×n$的矩阵，那么称$m×n$的矩阵C为矩阵A与B的乘积，记作C=AB。<br>矩阵A与矩阵B相乘需要满足条件：A的列数等于B的行数。</p>
<p>矩阵乘法举例：</p>
<p>令$A = \begin{bmatrix}<br>    1 &amp; 2  \<br>    3 &amp; 4 \<br>\end{bmatrix}$ ， $B = \begin{bmatrix}<br>    5 &amp; 6  \<br>    7 &amp; 8 \<br>\end{bmatrix}$， 则：</p>
<p>$$C = AB = \begin{bmatrix}<br>    1 &amp; 2  \<br>    3 &amp; 4 \<br>\end{bmatrix} × \begin{bmatrix}<br>    5 &amp; 6  \<br>    7 &amp; 8 \<br>\end{bmatrix} = \begin{bmatrix}<br>    1×5+2×7 &amp; 1×6+2×8  \<br>    3×5+4×7 &amp; 3×6+4×8 \<br>\end{bmatrix} = \begin{bmatrix}<br>    19 &amp; 22  \<br>    43 &amp; 50 \<br>\end{bmatrix}$$ </p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MatrixMultiply</span><span class="params">(matrix_a, matrix_b)</span>:</span></span><br><span class="line">    n_row = len(matrix_a)</span><br><span class="line">    n_col = len(matrix_b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># C的行数等于A的行数，C的列数等于B的列数</span></span><br><span class="line">    matrix_c = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n_col)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n_row)] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n_col):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, n_row):</span><br><span class="line">                matrix_c[i][j] = matrix_c[i][j] + matrix_a[i][k] * matrix_b[k][j]</span><br><span class="line">    <span class="keyword">return</span> matrix_c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">b = [[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">c = MatrixMultiply(a, b)</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># [[19, 22], [43, 50]]</span></span><br></pre></td></tr></table></figure>

<p>且矩阵乘法满足结合律：</p>
<p>$$A^{11} = A^8 × A^2 × A^1 = \begin{bmatrix}<br>    1 &amp; 2  \<br>    3 &amp; 4 \<br>\end{bmatrix} ^ 8 × \begin{bmatrix}<br>    1 &amp; 2  \<br>    3 &amp; 4 \<br>\end{bmatrix} ^ 2 × \begin{bmatrix}<br>    1 &amp; 2  \<br>    3 &amp; 4 \<br>\end{bmatrix} ^ 1$$ </p>
<hr>
<h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p>现在知道了两个矩阵乘法运算，那么如果求矩阵A的n次方$A^n$，可以用$A^n = A×A×A×…×A$，不过学习了计算底数$x$的n次幂$x^n$ 的快速幂方法，把底数$x$换成矩阵A，计算$A^n$，使用上面快速幂的方法同样可以实现矩阵快速幂。</p>
<p>结合快速幂和矩阵乘法，实现代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MatrixMultiply</span><span class="params">(matrix_a, matrix_b)</span>:</span></span><br><span class="line">    n_row = len(matrix_a)</span><br><span class="line">    n_col = len(matrix_b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># C的行数等于A的行数，C的列数等于B的列数</span></span><br><span class="line">    matrix_c = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n_col)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n_row)] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n_col):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, n_row):</span><br><span class="line">                matrix_c[i][j] = matrix_c[i][j] + matrix_a[i][k] * matrix_b[k][j]</span><br><span class="line">    <span class="keyword">return</span> matrix_c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUnitMatrix</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="comment"># 构造单位矩阵，l为矩阵a的行数</span></span><br><span class="line">    unit_matrix = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(l)] <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(l):</span><br><span class="line">        unit_matrix[k][k] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> unit_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickMatrixPow</span><span class="params">(a, n)</span>:</span></span><br><span class="line">    <span class="comment"># res_matrix初始化为单位矩阵</span></span><br><span class="line">    res_matrix = getUnitMatrix(len(a))</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">            res_matrix = MatrixMultiply(res_matrix, a)</span><br><span class="line">        a = MatrixMultiply(a,a)</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">n = <span class="number">11</span></span><br><span class="line">print(QuickMatrixPow(a,n))</span><br><span class="line"><span class="comment"># [[25699957, 37455814], [56183721, 81883678]]</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="扩展：斐波那契数列矩阵算法"><a href="#扩展：斐波那契数列矩阵算法" class="headerlink" title="扩展：斐波那契数列矩阵算法"></a>扩展：斐波那契数列矩阵算法</h4><p>关于斐波那契数列的定义：</p>
<blockquote><p>斐波那契数列（意大利语：Successione di Fibonacci），又译为费波拿契数列、费波那西数列、斐波那契数列、黄金分割数列。</p>
<p>在数学上，费波那契数列是以递归的方法来定义：</p>
<ul>
<li>$F(0) = 0$</li>
<li>$F(1) = 1$</li>
<li>$F(n) = F(n-1) + F(n-2) (n&gt;=2)$</li>
</ul>
<p>用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。首几个费波那契系数是：</p>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……（OEIS中的数列A000045）</p>
<p>特别指出：0不是第一项，而是第零项。</p>
<footer><strong>维基百科:</strong><cite><a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener">斐波那契数列</a></cite></footer></blockquote>

<p>将$ F(n)=F(n-1)+F(n-2)$用矩阵表示：<br>$$\begin{bmatrix}<br>    F(n)=F(n-1)+F(n-2)  \<br>    F(n-1) \<br>\end{bmatrix} = \begin{bmatrix}<br>    1 &amp; 1  \<br>    1 &amp; 0 \<br>\end{bmatrix} × \begin{bmatrix}<br>    F(n-1)  \<br>    F(n-2) \<br>\end{bmatrix}$$ </p>
<p>而$F(n-1)、F(n-2)、F(n-3)$也可以用同样的矩阵表示方式，于是有：<br>$$\begin{bmatrix}<br>    F(n)  \<br>    F(n-1) \<br>\end{bmatrix} = \begin{bmatrix}<br>    1 &amp; 1  \<br>    1 &amp; 0 \<br>\end{bmatrix} × \begin{bmatrix}<br>    F(n-1)  \<br>    F(n-2) \<br>\end{bmatrix} = \begin{bmatrix}<br>    1 &amp; 1  \<br>    1 &amp; 0 \<br>\end{bmatrix}^2 × \begin{bmatrix}<br>    F(n-2)  \<br>    F(n-3) \<br>\end{bmatrix} = … = \begin{bmatrix}<br>    1 &amp; 1  \<br>    1 &amp; 0 \<br>\end{bmatrix}^{n-1} × \begin{bmatrix}<br>    F(1)  \<br>    F(0) \<br>\end{bmatrix}$$ </p>
<p>得到： $\begin{bmatrix}<br>    F(n)  \<br>    F(n-1) \<br>\end{bmatrix} = \begin{bmatrix}<br>    1 &amp; 1  \<br>    1 &amp; 0 \<br>\end{bmatrix}^{n-1} × \begin{bmatrix}<br>    F(1)  \<br>    F(0) \<br>\end{bmatrix}$</p>
<p>我们知道$\begin{bmatrix}<br>    F(1)=1  \<br>    F(0)=0 \<br>\end{bmatrix}$,且$\begin{bmatrix}<br>    1 &amp; 1  \<br>    1 &amp; 0 \<br>\end{bmatrix}^{n-1}$可以用上面介绍的矩阵快速幂计算出来，两者相乘得到矩阵的第1行第1列就是$F(n)$了。</p>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MatrixMultiply</span><span class="params">(matrix_a, matrix_b)</span>:</span></span><br><span class="line">    n_row = len(matrix_a)</span><br><span class="line">    n_col = len(matrix_b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># C的行数等于A的行数，C的列数等于B的列数</span></span><br><span class="line">    matrix_c = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n_col)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n_row)] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n_col):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, n_row):</span><br><span class="line">                matrix_c[i][j] = matrix_c[i][j] + matrix_a[i][k] * matrix_b[k][j]</span><br><span class="line">    <span class="keyword">return</span> matrix_c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_unit_matrix</span><span class="params">(l)</span>:</span></span><br><span class="line">    unit_matrix = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(l)] <span class="keyword">for</span> i <span class="keyword">in</span> range(l)]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(l):</span><br><span class="line">        unit_matrix[k][k] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> unit_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickMatrixPow</span><span class="params">(a, n)</span>:</span></span><br><span class="line">    res_matrix = get_unit_matrix(len(a))</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">            res_matrix = MatrixMultiply(res_matrix, a)</span><br><span class="line">        a = MatrixMultiply(a,a)</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_Fib_n</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">        base = [[<span class="number">1</span>],[<span class="number">0</span>]]</span><br><span class="line">        Fib_n = MatrixMultiply(QuickMatrixPow(a,n<span class="number">-1</span>),base)</span><br><span class="line">        <span class="keyword">return</span> Fib_n[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 求斐波那契数列第F(n)个数</span></span><br><span class="line">    n = <span class="number">8</span>  </span><br><span class="line">    print(get_Fib_n(n))</span><br><span class="line">    <span class="comment"># 21</span></span><br></pre></td></tr></table></figure>

<p>结束。</p>
</div></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://huanyouchen.github.io/2018/05/23/Quick-Matrix-Pow/';
    this.page.identifier = '2018/05/23/Quick-Matrix-Pow/';
    this.page.title = '矩阵快速幂';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//huanyouchen-blog.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//huanyouchen-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://huanyouchen-blog.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">幻悠尘的小窝.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>